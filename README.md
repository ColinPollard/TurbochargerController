# TurbochargerController: Colin Pollard, McKay Mower, Luke Majors
An absolute pressure turbocharger controller, suited for aircraft use. 

---
## Overview:
All turbocharger systems have a wastegate valve which actuates based on the pressure generated by the turbine. If this pressure exceeds a limit, the wastegate opens to let some of this air out of the system, preventing potential damage to the engine. In cars and other ground-based vehicles, this valve can be mechanical where an actuator measures the difference between outside air and the pressurized air from the turbo. If this differential gets to be too large, the valve opens. A problem arises when using this type of system on an airborne unit since the air density is not fixed. If the outside pressure drops due to alitutde, the wastegate valve can be open for longer than intended since the pressure differential will be always be high. 

The solution is to use an absolute pressure reading. While this can be acomplished by utilizing a mechanical unit, there are advantages to being able to set the desired output pressure from the turbocharger, such as setting efficient cruise power levels and optimizing the range of operation of the turbocharger based on altitude. For this, an electronic solution is needed.

For this implementation, there are two major devices. The first is a raspberrypi based display that handles all inputs from the user. This device will send desired valve positions and receive pressure and status back over RS232. The second device is an STM32 based unit that collects and processes sensor data, while driving the valves to the desired positions as commanded by the raspberrypi. An absolute pressure sensor is used to measure the downstream pressure from the turbocharger. A stepper motor is used to drive the slow-moving wastegate valve, while a PWM signal is used to pulse the fast-moving bypass solenoid valve. All connections are routed through a DE9 connector using a custom wiring harness.

## Demonstration:
https://www.youtube.com/watch?v=gG7AOT28C98

## Software Design:
* RS232 Communication is handled through timers and interrupts. On receiving a command to move valve positions, an interrupt is triggered that sets desired position variables that are handled elsewhere. The systick interrupt is modified to send a status packet back to the pi every 2 seconds. 
* Stepper motor movement is handled on a timer, where position is tracked using an open loop controller. Every 10 miliseconds, the motor will move if there is an error between the current position and the desired position. The timer interval can be changed to increase or decrease the rate at which the motor moves. 
* The solenoid bypass valve is driven directly using the general timer 2 peripheral. A 30Hz carrier frequency is driven using a prescaled system clock. The duty cycle of this signal is updated on receiving a command from the pi.
* The pressure sensor is read from the ADC in a continuous conversion mode. The value is read during the RS232 transmission timer update.

## Hardware Design:
### Microcontroller
The microcontroller selected for this project is the NucleoL412KB. This is an STM32 board based around the cortex M4 core, packaged inside an arduino nano form factor. This was preferable for our project, since two headers can be placed on the PCB instead of a full microcontroller implementation. Pins were selected such that the timer peripheral, analog to digital converter, USART, and GPIO could be utilized most effectively for each of the applications below. Power to the system is supplied through the external 5v input, 3.3V power is generated through the MCU's onboard voltage regulator.

![MCU Schematic](/images/mcuschematic.PNG)

### Pressure Sensor
The pressure sensor used in this design is the NPP301. This sensor is an absolute pressure sensor capable of sensing up to 100psi. The device acts as a wheatstone bridge, where the resistance varies based on pressure. The sensor is connected to a two-stage amplifier stage, with a potentiometer available for sensitivity adjustment. This output feeds into the ADC12_channel1 of the microcontroller. 

![Pressure Sensor Schematic](/images/pressureschematic.PNG)

### Stepper Motor Driver:
The stepper motor driving stage is created using an A4988 "Stepstick" shield. Three general purpose output pins are used to drive the enable, direction, and step pins. The output of the motor is routed to a four-place screw terminal block for easy wiring to motors. Microstepping settings are selectable using a semi-permanent solder bridge feature on the back of the board. Power for the stepper motor is supplied through a separate motor supply line through the DE9.

![Stepper Motor Schematic](/images/stepperschematic.PNG)

### Solenoid Driver
The bypass valve is actuated using a 12v 32Hz PWM signal. In order to drive this load, a BJT driving stage was designed for this specific load and microcontroller. A diode is included on the load circuit to prevent reverse current due to the inductance of the solenoid valve. The base of the BJT is driven through a resistor by the general purpose TIM2_CH1. Power for driving the solenoid is sourced from an external high current supply pin through the DE9.

![Solenoid Driver Schematic](/images/solenoidschematic.PNG)

### RS232 Communications
A MAX3232 RS232 driver was utilized to convert the UART signal from the microcontroller to RS232 levels. This converter utilizes four external 0.1uF capacitors with a charge pump to increase the 3.3V supply to the correct level for communication.

![RS232 Driver Schematic](/images/rs232schematic.PNG)

---

![Block Diagram](/images/blockdiagram.PNG)

![Schematic](/images/TurbochargerController.jpg)
